// This file is part of the Acts project.
//
// Copyright (C) 2019-2024 CERN for the benefit of the Acts project
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

#include "ActsExamples/Io/Performance/TrackFinderPerformanceWriter.hpp"

#include "Acts/Definitions/Units.hpp"
#include "Acts/Utilities/VectorHelpers.hpp"
#include "ActsExamples/EventData/Index.hpp"
#include "ActsExamples/EventData/SimHit.hpp"
#include "ActsExamples/EventData/SimParticle.hpp"
#include "ActsExamples/EventData/TruthMatching.hpp"
#include "ActsExamples/Framework/AlgorithmContext.hpp"
#include "ActsExamples/Framework/DataHandle.hpp"
#include "ActsExamples/Utilities/Range.hpp"
#include "ActsExamples/Validation/TrackClassification.hpp"
#include "ActsFatras/EventData/Barcode.hpp"
#include "ActsFatras/EventData/Particle.hpp"

#include <cstddef>
#include <cstdint>
#include <mutex>
#include <stdexcept>
#include <unordered_map>
#include <utility>
#include <vector>

#include <RtypesCore.h>
#include <TFile.h>
#include <TTree.h>
#include <TVectorT.h>

namespace ActsExamples {

namespace {

using ParticleOnTracksCount =
    std::unordered_map<ActsFatras::Barcode, std::size_t>;

std::size_t getParticleCountOnTracks(
    const ParticleOnTracksCount& particleOnTracksCount,
    const ActsFatras::Barcode& particleId) {
  auto it = particleOnTracksCount.find(particleId);
  return it != particleOnTracksCount.end() ? it->second : 0;
}

}  // namespace

struct TrackFinderPerformanceWriter::Impl {
  Config cfg;

  /// extra logger reference for the logging macros
  const Acts::Logger& _logger;

  ReadDataHandle<SimParticleContainer> inputParticles;
  ReadDataHandle<TrackParticleMatching> inputTrackParticleMatching;
  ReadDataHandle<ParticleTrackMatching> inputParticleTrackMatching;

  TFile* file = nullptr;

  /// per-track tree
  TTree* trkTree = nullptr;
  std::mutex trkMutex;
  // track identification
  ULong64_t trkEventId = 0;
  ULong64_t trkTrackId = 0;
  // track content
  /// number of hits on track
  UShort_t trkNumHits = 0;
  /// number of particles contained in the track
  UShort_t trkNumParticles = 0;
  /// track particle content; for each contributing particle, largest first
  std::vector<ULong64_t> trkParticleId;
  /// total number of hits generated by this particle
  std::vector<UShort_t> trkParticleNumHitsTotal;
  /// number of hits within this track
  std::vector<UShort_t> trkParticleNumHitsOnTrack;

  /// per-particle tree
  TTree* prtTree = nullptr;
  std::mutex prtMutex;
  // particle identification
  ULong64_t prtEventId = 0;
  ULong64_t prtParticleId = 0;
  Int_t prtParticleType = 0;
  // particle kinematics
  /// vertex position in mm
  float prtVx = 0, prtVy = 0, prtVz = 0;
  /// vertex time in ns
  float prtVt = 0;
  /// particle momentum at production in GeV
  float prtPx = 0, prtPy = 0, prtPz = 0;
  /// particle mass in GeV
  float prtM = 0;
  /// particle charge in e
  float prtQ = 0;
  // particle reconstruction
  /// number of hits for this particle
  UShort_t prtNumHits = 0;
  /// number of tracks this particle was reconstructed in
  UShort_t prtNumTracks = 0;
  /// number of tracks reconstructed as majority
  UShort_t prtNumTracksMajority = 0;

  /// Plot tool for efficiency
  EffPlotTool m_effPlotTool;
  EffPlotTool::EffPlotCache m_effPlotCache;
  /// Plot tool for fake rate
  FakeRatePlotTool m_fakeRatePlotTool;
  FakeRatePlotTool::FakeRatePlotCache m_fakeRatePlotCache{};
  /// Plot tool for duplication rate
  DuplicationPlotTool m_duplicationPlotTool;
  DuplicationPlotTool::DuplicationPlotCache m_duplicationPlotCache{};
  /// Plot tool for track hit info
  TrackSummaryPlotTool m_trackSummaryPlotTool;
  TrackSummaryPlotTool::TrackSummaryPlotCache m_trackSummaryPlotCache{};

  // Adding numbers for efficiency, fake, duplicate calculations
  std::size_t m_nTotalTracks = 0;
  std::size_t m_nTotalMatchedTracks = 0;
  std::size_t m_nTotalFakeTracks = 0;
  std::size_t m_nTotalDuplicateTracks = 0;
  std::size_t m_nTotalParticles = 0;
  std::size_t m_nTotalMatchedParticles = 0;
  std::size_t m_nTotalDuplicateParticles = 0;
  std::size_t m_nTotalFakeParticles = 0;

  Impl(TrackFinderPerformanceWriter* parent, const Config& c,
       Acts::Logging::Level level)
      : cfg(c),
        _logger(parent->logger()),
        inputParticles{parent, "InputParticles"},
        inputTrackParticleMatching{parent, "InputTrackParticleMatching"},
        inputParticleTrackMatching{parent, "InputParticleTrackMatching"},
        m_effPlotTool(cfg.effPlotToolConfig, level),
        m_fakeRatePlotTool(cfg.fakeRatePlotToolConfig, level),
        m_duplicationPlotTool(cfg.duplicationPlotToolConfig, level),
        m_trackSummaryPlotTool(cfg.trackSummaryPlotToolConfig, level) {
    if (cfg.inputTracks.empty()) {
      throw std::invalid_argument("Missing tracks input collection");
    }
    if (cfg.inputParticles.empty()) {
      throw std::invalid_argument("Missing particles input collection");
    }
    if (cfg.inputTrackParticleMatching.empty()) {
      throw std::invalid_argument(
          "Missing track-particle matching input collection");
    }
    if (cfg.inputParticleTrackMatching.empty()) {
      throw std::invalid_argument(
          "Missing particle-track matching input collection");
    }
    if (cfg.filePath.empty()) {
      throw std::invalid_argument("Missing output filename");
    }

    inputParticles.initialize(cfg.inputParticles);
    inputTrackParticleMatching.initialize(cfg.inputTrackParticleMatching);

    // the output file can not be given externally since TFile accesses to the
    // same file from multiple threads are unsafe.
    // must always be opened internally
    file = TFile::Open(cfg.filePath.c_str(), cfg.fileMode.c_str());
    if (file == nullptr) {
      throw std::invalid_argument("Could not open '" + cfg.filePath + "'");
    }

    // construct trees
    trkTree = new TTree(cfg.treeNameTracks.c_str(), cfg.treeNameTracks.c_str());
    trkTree->SetDirectory(file);
    trkTree->Branch("event_id", &trkEventId);
    trkTree->Branch("track_id", &trkTrackId);
    trkTree->Branch("size", &trkNumHits);
    trkTree->Branch("nparticles", &trkNumParticles);
    trkTree->Branch("particle_id", &trkParticleId);
    trkTree->Branch("particle_nhits_total", &trkParticleNumHitsTotal);
    trkTree->Branch("particle_nhits_on_track", &trkParticleNumHitsOnTrack);
    prtTree =
        new TTree(cfg.treeNameParticles.c_str(), cfg.treeNameParticles.c_str());
    prtTree->SetDirectory(file);
    prtTree->Branch("event_id", &prtEventId);
    prtTree->Branch("particle_id", &prtParticleId);
    prtTree->Branch("particle_type", &prtParticleType);
    prtTree->Branch("vx", &prtVx);
    prtTree->Branch("vy", &prtVy);
    prtTree->Branch("vz", &prtVz);
    prtTree->Branch("vt", &prtVt);
    prtTree->Branch("px", &prtPx);
    prtTree->Branch("py", &prtPy);
    prtTree->Branch("pz", &prtPz);
    prtTree->Branch("m", &prtM);
    prtTree->Branch("q", &prtQ);
    prtTree->Branch("nhits", &prtNumHits);
    prtTree->Branch("ntracks", &prtNumTracks);
    prtTree->Branch("ntracks_majority", &prtNumTracksMajority);

    // initialize the plot tools
    m_effPlotTool.book(m_effPlotCache);
    m_fakeRatePlotTool.book(m_fakeRatePlotCache);
    m_duplicationPlotTool.book(m_duplicationPlotCache);
    m_trackSummaryPlotTool.book(m_trackSummaryPlotCache);
  }

  ~Impl() {
    m_effPlotTool.clear(m_effPlotCache);
    m_fakeRatePlotTool.clear(m_fakeRatePlotCache);
    m_duplicationPlotTool.clear(m_duplicationPlotCache);
    m_trackSummaryPlotTool.clear(m_trackSummaryPlotCache);
    if (file != nullptr) {
      file->Close();
    }
  }

  const Acts::Logger& logger() const { return _logger; }

  void writeTrackPerformance(std::uint64_t eventId,
                             const TrackContainer& tracks,
                             const TrackParticleMatching& trackParticleMatching,
                             ParticleOnTracksCount& particleOnTracksCount) {
    // write per-track performance measures
    {
      std::lock_guard<std::mutex> guardTrk(trkMutex);
      for (const auto& track : tracks) {
        // Counting number of total tracks
        m_nTotalTracks += 1;

        // Check if the reco track has fitted track parameters
        if (!track.hasReferenceSurface()) {
          ACTS_WARNING("No fitted track parameters for track, index = "
                       << track.index() << " tip index = " << track.tipIndex());
          continue;
        }

        Acts::BoundTrackParameters fittedParameters =
            track.createParametersAtReference();

        // Fill the trajectory summary info
        m_trackSummaryPlotTool.fill(m_trackSummaryPlotCache, fittedParameters,
                                    track.nTrackStates(), track.nMeasurements(),
                                    track.nOutliers(), track.nHoles(),
                                    track.nSharedHits());

        // Get the truth matching information
        auto imatched = trackParticleMatching.find(track.index());
        if (imatched == trackParticleMatching.end()) {
          ACTS_DEBUG("No truth matching information for this track, index = "
                     << track.index() << " tip index = " << track.tipIndex());
          continue;
        }

        const auto& particleMatch = imatched->second;

        for (const auto& phc : particleMatch.contributingParticles) {
          ++particleOnTracksCount[phc.particleId];
        }

        if (particleMatch.classification == TrackMatchClassification::Fake) {
          m_nTotalFakeTracks++;
        }

        if (particleMatch.classification ==
            TrackMatchClassification::Duplicate) {
          m_nTotalDuplicateTracks++;
        }

        trkEventId = eventId;
        trkTrackId = track.index();
        trkNumHits = track.nMeasurements();
        trkNumParticles = particleMatch.contributingParticles.size();
        trkParticleId.clear();
        trkParticleNumHitsTotal.clear();
        trkParticleNumHitsOnTrack.clear();
        for (const auto& phc : particleMatch.contributingParticles) {
          trkParticleId.push_back(phc.particleId.value());
          trkParticleNumHitsTotal.push_back(phc.hitCount);
          trkParticleNumHitsOnTrack.push_back(phc.hitCount);
        }

        trkTree->Fill();

        // Fill fake rate plots
        m_fakeRatePlotTool.fill(
            m_fakeRatePlotCache, fittedParameters,
            particleMatch.classification == TrackMatchClassification::Fake);

        // Fill the duplication rate
        m_duplicationPlotTool.fill(m_duplicationPlotCache, fittedParameters,
                                   particleMatch.classification ==
                                       TrackMatchClassification::Duplicate);
      }
    }
  }

  void writeParticlePerformance(
      std::uint64_t eventId, const SimParticleContainer& particles,
      const ParticleTrackMatching& particleTrackMatching,
      const ParticleOnTracksCount& particleOnTracksCount) {
    // write per-particle performance measures
    {
      std::lock_guard<std::mutex> guardPrt(prtMutex);
      for (const auto& particle : particles) {
        auto particleId = particle.particleId();

        // Counting number of total particles
        m_nTotalParticles += 1;

        // identification
        prtEventId = eventId;
        prtParticleId = particleId.value();
        prtParticleType = particle.pdg();
        // kinematics
        prtVx = particle.position().x() / Acts::UnitConstants::mm;
        prtVy = particle.position().y() / Acts::UnitConstants::mm;
        prtVz = particle.position().z() / Acts::UnitConstants::mm;
        prtVt = particle.time() / Acts::UnitConstants::mm;
        const auto p = particle.absoluteMomentum() / Acts::UnitConstants::GeV;
        prtPx = p * particle.direction().x();
        prtPy = p * particle.direction().y();
        prtPz = p * particle.direction().z();
        prtM = particle.mass() / Acts::UnitConstants::GeV;
        prtQ = particle.charge() / Acts::UnitConstants::e;

        // Investigate the truth-matched tracks
        std::size_t nMatchedTracks = 0;
        std::size_t nFakeTracks = 0;
        bool isReconstructed = false;
        if (auto imatched = particleTrackMatching.find(particleId);
            imatched != particleTrackMatching.end()) {
          const ParticleMatchEntry& matchEntry = imatched->second;

          nMatchedTracks =
              (matchEntry.track.has_value() ? 1 : 0) + matchEntry.duplicates;

          // Add number for total matched tracks here
          m_nTotalMatchedTracks += nMatchedTracks;
          m_nTotalMatchedParticles += 1;

          // Check if the particle has more than one matched track for the
          // duplicate rate
          if (nMatchedTracks > 1) {
            m_nTotalDuplicateParticles += 1;
          }
          isReconstructed = matchEntry.track.has_value();

          nFakeTracks = matchEntry.fakes;
          if (nFakeTracks > 0) {
            m_nTotalFakeParticles += 1;
          }
        }

        // reconstruction
        prtNumHits = particle.numberOfHits();
        prtNumTracks = getParticleCountOnTracks(particleOnTracksCount,
                                                particle.particleId());
        prtNumTracksMajority = nMatchedTracks;

        prtTree->Fill();

        // update the performance plots

        // Loop over all the other truth particle and find the distance to the
        // closest one
        double minDeltaR = -1;
        for (const auto& closeParticle : particles) {
          if (closeParticle.particleId() == particleId) {
            continue;
          }
          double p_phi = Acts::VectorHelpers::phi(particle.direction());
          double p_eta = Acts::VectorHelpers::eta(particle.direction());
          double c_phi = Acts::VectorHelpers::phi(closeParticle.direction());
          double c_eta = Acts::VectorHelpers::eta(closeParticle.direction());
          double distance = sqrt(pow(p_phi - c_phi, 2) + pow(p_eta - c_eta, 2));
          if (minDeltaR == -1 || distance < minDeltaR) {
            minDeltaR = distance;
          }
        }

        // Fill efficiency plots
        m_effPlotTool.fill(m_effPlotCache, particle, minDeltaR,
                           isReconstructed);
        // Fill number of duplicated tracks for this particle
        m_duplicationPlotTool.fill(m_duplicationPlotCache, particle,
                                   nMatchedTracks - 1);

        // Fill number of reconstructed/truth-matched/fake tracks for this
        // particle
        m_fakeRatePlotTool.fill(m_fakeRatePlotCache, particle, nMatchedTracks,
                                nFakeTracks);
      }
    }
  }

  void write(std::uint64_t eventId, const TrackContainer& tracks,
             const SimParticleContainer& particles,
             const TrackParticleMatching& trackParticleMatching,
             const ParticleTrackMatching& particleTrackMatching) {
    // How often a particle was seen across different tracks.
    ParticleOnTracksCount particleOnTracksCount;
    particleOnTracksCount.reserve(particles.size());

    writeTrackPerformance(eventId, tracks, trackParticleMatching,
                          particleOnTracksCount);

    writeParticlePerformance(eventId, particles, particleTrackMatching,
                             particleOnTracksCount);
  }

  /// Write everything to disk and close the file.
  ProcessCode finalize() {
    float eff_tracks =
        static_cast<float>(m_nTotalMatchedTracks) / m_nTotalTracks;
    float fakeRate_tracks =
        static_cast<float>(m_nTotalFakeTracks) / m_nTotalTracks;
    float duplicationRate_tracks =
        static_cast<float>(m_nTotalDuplicateTracks) / m_nTotalTracks;

    float eff_particle =
        static_cast<float>(m_nTotalMatchedParticles) / m_nTotalParticles;
    float fakeRate_particle =
        static_cast<float>(m_nTotalFakeParticles) / m_nTotalParticles;
    float duplicationRate_particle =
        static_cast<float>(m_nTotalDuplicateParticles) / m_nTotalParticles;

    ACTS_DEBUG("nTotalTracks                = " << m_nTotalTracks);
    ACTS_DEBUG("nTotalMatchedTracks         = " << m_nTotalMatchedTracks);
    ACTS_DEBUG("nTotalDuplicateTracks       = " << m_nTotalDuplicateTracks);
    ACTS_DEBUG("nTotalFakeTracks            = " << m_nTotalFakeTracks);

    ACTS_INFO(
        "Efficiency with tracks (nMatchedTracks/ nAllTracks) = " << eff_tracks);
    ACTS_INFO(
        "Fake rate with tracks (nFakeTracks/nAllTracks) = " << fakeRate_tracks);
    ACTS_INFO("Duplicate rate with tracks (nDuplicateTracks/nAllTracks) = "
              << duplicationRate_tracks);
    ACTS_INFO("Efficiency with particles (nMatchedParticles/nTrueParticles) = "
              << eff_particle);
    ACTS_INFO("Fake rate with particles (nFakeParticles/nTrueParticles) = "
              << fakeRate_particle);
    ACTS_INFO(
        "Duplicate rate with particles (nDuplicateParticles/nTrueParticles) = "
        << duplicationRate_particle);

    auto writeFloat = [&](float f, const char* name) {
      TVectorF v(1);
      v[0] = f;
      file->WriteObject(&v, name);
    };

    if (file != nullptr) {
      file->cd();
      m_effPlotTool.write(m_effPlotCache);
      m_fakeRatePlotTool.write(m_fakeRatePlotCache);
      m_duplicationPlotTool.write(m_duplicationPlotCache);
      m_trackSummaryPlotTool.write(m_trackSummaryPlotCache);
      writeFloat(eff_tracks, "eff_tracks");
      writeFloat(fakeRate_tracks, "fakerate_tracks");
      writeFloat(duplicationRate_tracks, "duplicaterate_tracks");
      writeFloat(eff_particle, "eff_particles");
      writeFloat(fakeRate_particle, "fakerate_particles");
      writeFloat(duplicationRate_particle, "duplicaterate_particles");

      ACTS_INFO("Wrote performance plots to '" << file->GetPath() << "'");
    }
    return ProcessCode::SUCCESS;
  }
};

TrackFinderPerformanceWriter::TrackFinderPerformanceWriter(
    const Config& config, Acts::Logging::Level level)
    : WriterT(config.inputTracks, "TrackFinderPerformanceWriter", level),
      m_impl(std::make_unique<Impl>(this, config, level)) {}

TrackFinderPerformanceWriter::~TrackFinderPerformanceWriter() = default;

ProcessCode TrackFinderPerformanceWriter::writeT(const AlgorithmContext& ctx,
                                                 const TrackContainer& tracks) {
  const auto& particles = m_impl->inputParticles(ctx);
  const auto& trackParticleMatching = m_impl->inputTrackParticleMatching(ctx);
  const auto& particleTrackMatching = m_impl->inputParticleTrackMatching(ctx);
  m_impl->write(ctx.eventNumber, tracks, particles, trackParticleMatching,
                particleTrackMatching);
  return ProcessCode::SUCCESS;
}

ProcessCode TrackFinderPerformanceWriter::finalize() {
  return m_impl->finalize();
}

const TrackFinderPerformanceWriter::Config&
TrackFinderPerformanceWriter::config() const {
  return m_impl->cfg;
}

}  // namespace ActsExamples
